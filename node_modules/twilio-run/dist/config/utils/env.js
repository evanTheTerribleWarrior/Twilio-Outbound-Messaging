"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterEnvVariablesForDeploy = exports.readLocalEnvFile = void 0;
const common_tags_1 = require("common-tags");
const dotenv_1 = __importDefault(require("dotenv"));
const path_1 = __importDefault(require("path"));
const fs_1 = require("../../utils/fs");
function readLocalEnvFile(flags) {
    return __awaiter(this, void 0, void 0, function* () {
        if (flags.loadSystemEnv && typeof flags.env === 'undefined') {
            throw new Error(common_tags_1.stripIndent `
      If you are using --load-system-env you'll also have to supply a --env flag.
      
      The .env file you are pointing at will be used to primarily load environment variables.
      Any empty entries in the .env file will fall back to the system's environment variables.
    `);
        }
        if (flags.cwd) {
            const envPath = path_1.default.resolve(flags.cwd, flags.env || '.env');
            let contentEnvFile;
            if (yield fs_1.fileExists(envPath)) {
                contentEnvFile = yield fs_1.readFile(envPath, 'utf8');
            }
            else if (flags.env) {
                throw new Error(`Failed to find .env file at "${envPath}"`);
            }
            else {
                contentEnvFile = '';
            }
            let localEnv;
            try {
                localEnv = dotenv_1.default.parse(contentEnvFile);
            }
            catch (err) {
                throw new Error('Failed to parse .env file');
            }
            if (flags.loadSystemEnv && typeof flags.env !== 'undefined') {
                for (const key of Object.keys(localEnv)) {
                    const systemValue = process.env[key];
                    if (systemValue) {
                        localEnv[key] = localEnv[key] || systemValue;
                    }
                }
            }
            return { localEnv, envPath };
        }
        return { envPath: '', localEnv: {} };
    });
}
exports.readLocalEnvFile = readLocalEnvFile;
function filterEnvVariablesForDeploy(localEnv) {
    const env = Object.assign({}, localEnv);
    for (let key of Object.keys(env)) {
        const val = env[key];
        if (typeof val === 'string' && val.length === 0) {
            delete env[key];
        }
    }
    delete env.ACCOUNT_SID;
    delete env.AUTH_TOKEN;
    return env;
}
exports.filterEnvVariablesForDeploy = filterEnvVariablesForDeploy;
