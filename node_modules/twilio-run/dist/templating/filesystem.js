"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFiles = void 0;
const serverless_api_1 = require("@twilio-labs/serverless-api");
const chalk_1 = __importDefault(require("chalk"));
const dotenv_1 = __importDefault(require("dotenv"));
const got_1 = __importDefault(require("got"));
const listr_1 = __importDefault(require("listr"));
const path_1 = __importDefault(require("path"));
const pkg_install_1 = require("pkg-install");
const semver_1 = __importDefault(require("semver"));
const fs_1 = require("../utils/fs");
const logger_1 = require("../utils/logger");
function writeEnvFile(contentUrl, targetDir, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const envFilePath = path_1.default.join(targetDir, '.env');
        const envFileExists = yield fs_1.fileExists(envFilePath);
        if (!envFileExists) {
            yield fs_1.downloadFile(contentUrl, envFilePath);
            return { newEnvironmentVariableKeys: [] };
        }
        const currentContent = yield fs_1.readFile(envFilePath, 'utf8');
        const currentFlags = dotenv_1.default.parse(currentContent);
        const newContent = (yield got_1.default(contentUrl)).body;
        const newFlags = dotenv_1.default.parse(newContent);
        const functionKeys = Object.keys(newFlags);
        const existingKeys = functionKeys.filter((key) => currentFlags.hasOwnProperty(key));
        const updatedContent = newContent
            .split('\n')
            .map((line) => {
            const name = line.substr(0, line.indexOf('='));
            if (existingKeys.includes(name)) {
                return '# ' + line;
            }
            return line;
        })
            .join('\n');
        const separatorContent = `

# Variables for function "${functionName}"
# ---
`;
        const contentToWrite = currentContent + separatorContent + updatedContent;
        yield fs_1.writeFile(envFilePath, contentToWrite, 'utf8');
        return { newEnvironmentVariableKeys: functionKeys };
    });
}
function installDependencies(contentUrl, targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgContent = yield got_1.default(contentUrl, { json: true });
        const dependencies = {};
        const exactDependencies = {};
        Object.entries(pkgContent.body.dependencies).forEach(([name, version]) => {
            if (Boolean(semver_1.default.parse(version))) {
                exactDependencies[name] = version;
            }
            else {
                dependencies[name] = version;
            }
        });
        if (exactDependencies && Object.keys(exactDependencies).length > 0) {
            yield pkg_install_1.install(exactDependencies, {
                cwd: targetDir,
                exact: true,
            });
        }
        if (dependencies && Object.keys(dependencies).length > 0) {
            return pkg_install_1.install(dependencies, {
                cwd: targetDir,
            });
        }
    });
}
function hasFilesOfType(files, type) {
    for (let file of files) {
        if (file.type === type) {
            return true;
        }
    }
    return false;
}
function writeFiles(files, targetDir, namespace, templateName) {
    return __awaiter(this, void 0, void 0, function* () {
        const functionsDir = serverless_api_1.fsHelpers.getFirstMatchingDirectory(targetDir, [
            'functions',
            'src',
        ]);
        const assetsDir = serverless_api_1.fsHelpers.getFirstMatchingDirectory(targetDir, [
            'assets',
            'static',
        ]);
        const functionsTargetDir = path_1.default.join(functionsDir, namespace);
        const assetsTargetDir = path_1.default.join(assetsDir, namespace);
        const readmesTargetDir = path_1.default.join(targetDir, 'readmes', namespace);
        if (functionsTargetDir !== functionsDir) {
            if (hasFilesOfType(files, 'functions')) {
                yield fs_1.mkdir(functionsTargetDir, { recursive: true });
            }
            if (hasFilesOfType(files, 'assets')) {
                yield fs_1.mkdir(assetsTargetDir, { recursive: true });
            }
        }
        if (hasFilesOfType(files, 'README.md')) {
            yield fs_1.mkdir(readmesTargetDir, { recursive: true });
        }
        for (let file of files) {
            if (file.type === 'functions') {
                let filepath = path_1.default.join(functionsTargetDir, file.directory, file.name);
                if (yield fs_1.fileExists(filepath)) {
                    throw new Error(`Template with name "${namespace}" has duplicate file "${file.name}" in "${functionsDir}"`);
                }
            }
            else if (file.type === 'assets') {
                let filepath = path_1.default.join(assetsTargetDir, file.directory, file.name);
                if (yield fs_1.fileExists(filepath)) {
                    throw new Error(`Template with name "${namespace}" has duplicate file "${file.name}" in "${assetsDir}"`);
                }
            }
        }
        const tasks = files
            .map((file) => {
            if (file.type === 'functions') {
                return {
                    title: `Creating function: ${path_1.default.join(file.directory, file.name)}`,
                    task: () => fs_1.downloadFile(file.content, path_1.default.join(functionsTargetDir, file.directory, file.name)),
                };
            }
            else if (file.type === 'assets') {
                return {
                    title: `Creating asset: ${file.name}`,
                    task: () => fs_1.downloadFile(file.content, path_1.default.join(assetsTargetDir, file.directory, file.name)),
                };
            }
            else if (file.type === '.env' || file.type === '.env.example') {
                return {
                    title: 'Configuring Environment Variables in .env',
                    task: (ctx) => __awaiter(this, void 0, void 0, function* () {
                        const output = yield writeEnvFile(file.content, targetDir, namespace);
                        ctx.env = output;
                    }),
                };
            }
            else if (file.type === 'package.json') {
                return {
                    title: 'Installing Dependencies',
                    task: () => installDependencies(file.content, targetDir),
                };
            }
            else if (file.type === 'README.md') {
                const readmePath = path_1.default.join(readmesTargetDir, templateName + '.md');
                return {
                    title: `Saving README to ${readmePath}`,
                    task: () => __awaiter(this, void 0, void 0, function* () {
                        if (yield fs_1.fileExists(readmePath)) {
                            return;
                        }
                        return fs_1.downloadFile(file.content, readmePath);
                    }),
                };
            }
        })
            .filter(Boolean);
        const context = yield new listr_1.default(tasks, { concurrent: true }).run();
        const newKeys = context.env.newEnvironmentVariableKeys;
        if (newKeys.length > 0) {
            logger_1.logger.info(chalk_1.default `{cyan INFO} Make sure to configure ${newKeys.join(',')} in the .env file`);
        }
    });
}
exports.writeFiles = writeFiles;
