"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.describe = exports.command = exports.cliInfo = exports.handler = void 0;
const serverless_api_1 = require("@twilio-labs/serverless-api");
const common_tags_1 = require("common-tags");
const path_1 = __importDefault(require("path"));
const check_credentials_1 = require("../checks/check-credentials");
const check_runtime_handler_1 = require("../checks/check-runtime-handler");
const legacy_config_1 = __importDefault(require("../checks/legacy-config"));
const project_structure_1 = __importDefault(require("../checks/project-structure"));
const deploy_1 = require("../config/deploy");
const flags_1 = require("../flags");
const deploy_2 = require("../printers/deploy");
const utils_1 = require("../serverless-api/utils");
const logger_1 = require("../utils/logger");
const utils_2 = require("./utils");
const debug = logger_1.getDebugFunction('twilio-run:deploy');
function logError(msg) {
    logger_1.logger.error(msg);
}
function handleError(err, spinner, flags, config) {
    debug('%O', err);
    spinner.fail('Failed Deployment');
    if (err.name === 'conflicting-servicename') {
        const fullCommand = utils_2.getFullCommand(flags);
        const messageBody = common_tags_1.stripIndent `
      Here are a few ways to solve this problem:

      - Rename your project in the package.json "name" property
      - Pass an explicit name to your deployment
        > ${utils_2.constructCommandName(fullCommand, 'deploy', [
            '-n',
            'my-new-service-name',
        ])}
      - Deploy to the existing service with the name "${err['serviceName'] || config.serviceName}"
        > ${utils_2.constructCommandName(fullCommand, 'deploy', [
            '--override-existing-project',
        ])}
      - Run deployment in force mode
        > ${utils_2.constructCommandName(fullCommand, 'deploy', ['--force'])}
    `;
        logger_1.logger.error(messageBody, err.message);
    }
    else if (err.name === 'TwilioApiError') {
        logger_1.logApiError(logger_1.logger, err);
    }
    else {
        logger_1.logger.error(err.message);
    }
    process.exit(1);
}
function handler(flags, externalCliOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.setLogLevelByName(flags.logLevel);
        const cwd = flags.cwd ? path_1.default.resolve(flags.cwd) : process.cwd();
        flags.cwd = cwd;
        const continueWork = yield legacy_config_1.default(cwd);
        if (!continueWork) {
            process.exit(1);
        }
        const command = utils_2.getFullCommand(flags);
        yield project_structure_1.default(cwd, command, true);
        let config;
        try {
            config = yield deploy_1.getConfigFromFlags(flags, externalCliOptions);
        }
        catch (err) {
            debug(err);
            logError(err.message);
            process.exit(1);
            return;
        }
        if (!config) {
            logError('Internal Error');
            process.exit(1);
            return;
        }
        if (!check_runtime_handler_1.checkForValidRuntimeHandlerVersion(config.pkgJson)) {
            process.exit(1);
            return;
        }
        debug('Deploy Config %P', config);
        check_credentials_1.checkConfigForCredentials(config);
        deploy_2.printConfigInfo(config, config.outputFormat);
        const spinner = logger_1.getOraSpinner('Deploying Function').start();
        try {
            const client = new serverless_api_1.TwilioServerlessApiClient(config);
            client.on('status-update', (evt) => {
                spinner.text = evt.message + '\n';
            });
            const result = yield client.deployLocalProject(config);
            spinner.text = 'Serverless project successfully deployed\n';
            spinner.succeed();
            deploy_2.printDeployedResources(config, result, config.outputFormat);
            const { serviceSid, buildSid } = result;
            yield utils_1.saveLatestDeploymentData(config.cwd, serviceSid, buildSid, config.username.startsWith('AC')
                ? config.username
                : externalCliOptions && externalCliOptions.accountSid);
        }
        catch (err) {
            handleError(err, spinner, flags, config);
        }
    });
}
exports.handler = handler;
exports.cliInfo = {
    options: Object.assign(Object.assign({}, flags_1.getRelevantFlags([
        ...flags_1.BASE_CLI_FLAG_NAMES,
        ...flags_1.BASE_API_FLAG_NAMES,
        'service-sid',
        'environment',
        'service-name',
        'override-existing-project',
        'force',
        'functions',
        'assets',
        'assets-folder',
        'functions-folder',
        'runtime',
        'output-format',
    ])), { production: Object.assign(Object.assign({}, flags_1.ALL_FLAGS['production']), { describe: 'Please prefer the "activate" command! Deploys to the production environment (no domain suffix). Overrides the value passed via the environment flag.', default: false }) }),
};
function optionBuilder(yargs) {
    yargs = yargs
        .example('$0 deploy', 'Deploys all functions and assets in the current working directory')
        .example('$0 deploy --environment=stage', 'Creates an environment with the domain suffix "stage"');
    yargs = Object.keys(exports.cliInfo.options).reduce((yargs, name) => {
        return yargs.option(name, exports.cliInfo.options[name]);
    }, yargs);
    return yargs;
}
exports.command = ['deploy'];
exports.describe = 'Deploys existing functions and assets to Twilio';
exports.builder = optionBuilder;
