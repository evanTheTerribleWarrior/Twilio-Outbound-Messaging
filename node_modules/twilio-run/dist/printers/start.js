"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printRouteInfo = void 0;
const boxen_1 = __importDefault(require("boxen"));
const chalk_1 = __importDefault(require("chalk"));
const log_symbols_1 = __importDefault(require("log-symbols"));
const wrap_ansi_1 = __importDefault(require("wrap-ansi"));
const runtime_paths_1 = require("../runtime/internal/runtime-paths");
const logger_1 = require("../utils/logger");
const utils_1 = require("./utils");
function printAsset(asset, config) {
    const prefix = config.legacyMode ? '/asset' : '';
    return chalk_1.default `{dim ${config.url}${prefix}}${asset.path}`;
}
function printFunction(fn, config) {
    return chalk_1.default `{dim ${config.url}}${fn.path}`;
}
function printPlainRouteInfo(functions, assets, config) {
    const functionHeading = 'Functions';
    let functionInfo;
    if (functions.length > 0) {
        functionInfo = functions.map((fn) => printFunction(fn, config)).join('\n');
    }
    else {
        functionInfo = 'No functions found';
    }
    const assetHeading = 'Assets';
    let assetInfo;
    if (assets.length > 0) {
        assetInfo = assets.map((asset) => printAsset(asset, config)).join('\n');
    }
    else {
        assetInfo = 'No assets found';
    }
    let ngrokInfo = '';
    if (config.url.includes('ngrok.io')) {
        ngrokInfo = 'ngrok request inspector available: http://127.0.0.1:4040';
    }
    const output = [
        functionHeading,
        functionInfo,
        '',
        assetHeading,
        assetInfo,
        '',
        ngrokInfo,
    ]
        .join('\n')
        .trim();
    return output;
}
function prettyPrintAsset(asset, config) {
    const prefix = config.legacyMode ? '/asset' : '';
    const assetPath = prefix + asset.path;
    const pathAccess = asset.access !== 'private'
        ? config.url + assetPath
        : `Runtime.getAssets()['${asset.path}']`;
    const accessPrefix = asset.access !== 'public' ? chalk_1.default.cyan.bold(`[${asset.access}] `) : '';
    const link = utils_1.terminalLink(`${accessPrefix}${assetPath}`, pathAccess);
    return link;
}
function prettyPrintFunction(fn, config) {
    const accessPrefix = fn.access === 'protected' ? chalk_1.default.cyan.bold('[protected] ') : '';
    const link = utils_1.terminalLink(`${accessPrefix}${fn.path}`, config.url + fn.path);
    return link;
}
function printPrettyRouteInfo(functions, assets, config) {
    const functionHeading = chalk_1.default `{green.bold Twilio functions available:}`;
    let functionInfo;
    if (functions.length > 0) {
        functionInfo = functions
            .map((fn, idx) => {
            const symbol = idx + 1 === functions.length ? '└──' : '├──';
            return `${symbol} ${prettyPrintFunction(fn, config)}`;
        })
            .join('\n');
    }
    else {
        functionInfo = chalk_1.default `  {yellow ${log_symbols_1.default.warning}} No functions found`;
    }
    const assetHeading = chalk_1.default `{green.bold Twilio assets available:}`;
    let assetInfo;
    if (assets.length > 0) {
        assetInfo = assets
            .map((asset, idx) => {
            const symbol = idx + 1 === assets.length ? '└──' : '├──';
            return `${symbol} ${prettyPrintAsset(asset, config)}`;
        })
            .join('\n');
    }
    else {
        assetInfo = chalk_1.default `  {yellow ${log_symbols_1.default.warning}} No assets found`;
    }
    let ngrokInfo = '';
    if (config.url.includes('ngrok.io')) {
        ngrokInfo = chalk_1.default `{green.bold ngrok request inspector available:}\nhttp://127.0.0.1:4040`;
    }
    const output = [
        functionHeading,
        functionInfo,
        '',
        assetHeading,
        assetInfo,
        '',
        ngrokInfo,
    ]
        .join('\n')
        .trim();
    const wrappedOutput = wrap_ansi_1.default(output, utils_1.windowSize.width - 8, {
        wordWrap: true,
    });
    return boxen_1.default(wrappedOutput, { padding: 1 });
}
// A magic function from https://fettblog.eu/typescript-hasownproperty/
// This narrows down a type based on the property that an object has. It is used
// below to distinguish between `StartCliConfig` and `ServerConfig` as the
// `ServerConfig` does not have functionsFolderName or assetsFolderName
// properties.
function hasOwnProperty(obj, prop) {
    return obj.hasOwnProperty(prop);
}
function printRouteInfo(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const searchConfig = {};
        if (hasOwnProperty(config, 'functionsFolderName') &&
            typeof config.functionsFolderName === 'string') {
            searchConfig.functionsFolderNames = [config.functionsFolderName];
        }
        if (hasOwnProperty(config, 'assetsFolderName') &&
            typeof config.assetsFolderName === 'string') {
            searchConfig.assetsFolderNames = [config.assetsFolderName];
        }
        const { functions, assets } = yield runtime_paths_1.getFunctionsAndAssets(config.baseDir, searchConfig);
        let output;
        if (utils_1.shouldPrettyPrint) {
            output = printPrettyRouteInfo(functions, assets, config);
        }
        else {
            output = printPlainRouteInfo(functions, assets, config);
        }
        logger_1.logger.info(output);
    });
}
exports.printRouteInfo = printRouteInfo;
