"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.overrideLogger = exports.logger = exports.getOraSpinner = exports.logApiError = exports.setLogLevelByName = exports.getDebugFunction = exports.Logger = exports.LoggingLevel = void 0;
const ora_1 = __importDefault(require("ora"));
const stream_1 = require("stream");
const terminal_link_1 = __importDefault(require("terminal-link"));
const utils_1 = require("../printers/utils");
const debug_1 = __importDefault(require("./debug"));
// an empty stream that immediately drops everything. Like /dev/null
const EmptyStream = new stream_1.Writable();
EmptyStream._write = (chunk, encoding, callback) => {
    setImmediate(callback);
};
exports.LoggingLevel = {
    debug: -1,
    info: 0,
    warn: 1,
    error: 2,
    none: 10,
};
class Logger {
    constructor(opts) {
        this.useDebugModule = true;
        this.options = opts;
        this.config = opts;
    }
    get config() {
        return this.options;
    }
    set config(val) {
        this.options = val;
        if (val.level === exports.LoggingLevel.debug) {
            const namespaces = ['twilio*'];
            if (process.env.DEBUG) {
                namespaces.push(process.env.DEBUG);
            }
            process.env.DEBUG = namespaces.join(',');
            debug_1.default.enable(process.env.DEBUG);
        }
    }
    debug(msg) {
        this.log(msg, exports.LoggingLevel.debug);
    }
    info(msg) {
        this.log(msg, exports.LoggingLevel.info);
    }
    warn(msg, title = '') {
        msg = utils_1.warningMessage(title, msg);
        this.log(msg, exports.LoggingLevel.warn);
    }
    error(msg, title = '') {
        msg = utils_1.errorMessage(title, msg);
        this.log(msg, exports.LoggingLevel.error);
    }
    log(msg, level) {
        level = level || exports.LoggingLevel.info;
        if (level >= this.config.level) {
            const message = typeof msg === 'string' ? msg : JSON.stringify(msg);
            process.stderr.write(message + '\n');
        }
    }
}
exports.Logger = Logger;
function getDebugFunction(namespace) {
    const debugLogger = debug_1.default(namespace);
    if (!exports.logger.useDebugModule) {
        debugLogger.enabled = true;
        debug_1.default.log = exports.logger.debug.bind(exports.logger);
    }
    return debugLogger;
}
exports.getDebugFunction = getDebugFunction;
function setLogLevelByName(name) {
    exports.logger.config = { level: exports.LoggingLevel[name] };
}
exports.setLogLevelByName = setLogLevelByName;
function logApiError(logger, err) {
    var _a;
    let messageBody = err.message;
    const moreInfoLink = (_a = err.details) === null || _a === void 0 ? void 0 : _a.more_info;
    if (typeof moreInfoLink === 'string') {
        const linkText = terminal_link_1.default(moreInfoLink, moreInfoLink, {
            fallback: () => moreInfoLink,
        });
        messageBody += `\n\nMore info: ${linkText}`;
    }
    const title = `Failed API Request ${err.code}`;
    logger.error(messageBody, title);
}
exports.logApiError = logApiError;
function getOraSpinner(options) {
    let oraOptions;
    if (typeof options === 'string') {
        oraOptions = {
            text: options,
        };
    }
    else if (typeof options === 'undefined') {
        oraOptions = {};
    }
    else {
        oraOptions = options;
    }
    if (exports.logger.config.level > exports.LoggingLevel.info) {
        oraOptions = Object.assign(Object.assign({}, oraOptions), { 
            // write to a stream that drops the content
            stream: EmptyStream });
    }
    return ora_1.default(oraOptions);
}
exports.getOraSpinner = getOraSpinner;
exports.logger = new Logger({
    level: exports.LoggingLevel.info,
});
function overrideLogger(newLogger) {
    exports.logger = newLogger;
}
exports.overrideLogger = overrideLogger;
