/** @module @twilio-labs/serverless-api/dist/utils/fs */
/// <reference types="node" />
import fs from 'fs';
import { DirectoryContent, FileInfo, ResourcePathAndAccess } from '../types';
export declare const access: typeof fs.access.__promisify__;
export declare const readFile: typeof fs.readFile.__promisify__;
export declare const writeFile: typeof fs.writeFile.__promisify__;
export declare const readDir: (arg1: string) => Promise<unknown>;
export declare const stat: typeof fs.stat.__promisify__;
/**
 * Checks if a given file exists by checking if we have read & write access
 *
 * @export
 * @param {string} filePath full path of the file to check
 * @returns
 */
export declare function fileExists(filePath: string): Promise<boolean>;
export declare type ValidPathResult = {
    valid: true;
} | {
    valid: false;
    message: string;
};
/**
 * Verifies a given path against the restrictions put up by the Twilio Runtime.
 *
 * @param path a potential absolute path for a Function or Asset
 */
export declare function checkForValidPath(path: string): ValidPathResult;
/**
 * Determines the access and Serverless path for a filesystem resource.
 * If it receives an ignore extension it will drop it from the final serverless path
 *
 * @export
 * @param {FileInfo} file the file to get the access and path for
 * @param {string} [ignoreExtension] file extension to drop for serverless path
 * @returns {ResourcePathAndAccess}
 */
export declare function getPathAndAccessFromFileInfo(file: FileInfo, ignoreExtension?: string): ResourcePathAndAccess;
/**
 * Retrieves all (nested) files from a given directory.
 *
 * If an extension is specified it will be used to filter the results.
 *
 * @export
 * @param {string} dir the directory to be checked
 * @param {string} [extension] extension to be ignored in the results
 * @returns {Promise<FileInfo[]>}
 */
export declare function getDirContent(dir: string, extension?: string): Promise<FileInfo[]>;
/**
 * Given a list of directory names it will return the first one that exists in
 * the base path.
 *
 * **Important**: Performs synchronous file system reading
 *
 * @export
 * @param {string} basePath
 * @param {string[]} directories
 * @returns {string}
 */
export declare function getFirstMatchingDirectory(basePath: string, directories: string[]): string;
export declare type SearchConfig = {
    /**
     * Ordered folder names to search for to find functions
     *
     * @type {string[]}
     */
    functionsFolderNames?: string[];
    /**
     * Ordered folder names to search for to find assets
     *
     * @type {string[]}
     */
    assetsFolderNames?: string[];
};
/**
 * Retrieves a list of functions and assets existing in a given base directory
 * Will check for both "functions" and "src" as directory for functions and
 * "assets" and "static" for assets
 *
 * @export
 * @param {string} cwd Directory
 * @param {SearchConfig} config lets you override the folders to use
 * @returns {Promise<DirectoryContent>}
 */
export declare function getListOfFunctionsAndAssets(cwd: string, config?: SearchConfig): Promise<DirectoryContent>;
